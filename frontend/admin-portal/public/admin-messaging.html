<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Admin Messaging - UAI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(to bottom, #2979ff 0%, #e3f0ff 100%);
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    /* Header */
    .header {
      background: #fff;
      padding: 15px 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .header h1 {
      color: #2979ff;
      margin: 0;
      font-size: 20px;
    }
    
    .back-btn {
      background: #2979ff;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      text-decoration: none;
      display: inline-block;
      font-size: 14px;
    }
    
    /* Main container */
    .main-container {
      flex: 1;
      display: flex;
      max-width: 1200px;
      margin: 0 auto;
      width: 100%;
      background: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    /* Sidebar */
    .user-panel {
      width: 300px;
      background: #f8f9fa;
      border-right: 1px solid #e9ecef;
      display: flex;
      flex-direction: column;
    }
    
    .online-users {
      padding: 20px;
      border-top: 1px solid #e9ecef;
      background: #f8f9fa;
    }
    
    .online-users h3 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 16px;
    }
    
    .users-list {
      max-height: 200px;
      overflow-y: auto;
    }
    
    .user-item {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      margin-bottom: 5px;
      background: white;
      border-radius: 8px;
      border: 1px solid #e9ecef;
    }
    
    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
      margin-right: 10px;
    }
    
    .user-avatar.admin {
      background: #2979ff;
      color: white;
    }
    
    .user-avatar.worker {
      background: #28a745;
      color: white;
    }
    
    .user-info {
      flex: 1;
    }
    
    .user-name {
      font-weight: 600;
      font-size: 14px;
      color: #333;
    }
    
    .user-role {
      font-size: 12px;
      color: #666;
    }
    
    .user-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #28a745;
      margin-left: 8px;
    }
    
    .user-status.offline {
      background: #dc3545;
    }
    
    .sidebar-header {
      padding: 20px;
      border-bottom: 1px solid #e9ecef;
      background: #fff;
    }
    
    .sidebar-header h2 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 18px;
    }
    
    
    .search-box {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      margin-top: 10px;
      font-size: 14px;
    }
    
    .contacts-list {
      flex: 1;
      overflow-y: auto;
    }
    
    .contact-item {
      padding: 15px 20px;
      border-bottom: 1px solid #e9ecef;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .contact-item:hover {
      background: #e9ecef;
    }
    
    .contact-item.active {
      background: #2979ff;
      color: white;
    }
    
    .contact-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #2979ff;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 16px;
    }
    
    .contact-avatar.admin {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-weight: bold;
    }
    
    .contact-avatar.worker {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      font-weight: bold;
    }
    
    .contact-item.active .contact-avatar {
      background: #fff;
      color: #2979ff;
    }
    
    .contact-info {
      flex: 1;
    }
    
    .contact-name {
      font-weight: 600;
      margin-bottom: 2px;
    }
    
    .contact-role {
      font-size: 12px;
      opacity: 0.7;
    }
    
    .contact-status {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #4caf50;
    }
    
    .contact-status.offline {
      background: #ccc;
    }
    
    /* Chat area */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    
    .chat-header {
      padding: 20px;
      border-bottom: 1px solid #e9ecef;
      background: #fff;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .chat-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #2979ff;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }
    
    .chat-info h3 {
      margin: 0;
      color: #333;
    }
    
    .chat-status {
      font-size: 12px;
      color: #666;
    }
    
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      background: #f8f9fa;
    }
    
    .message {
      margin-bottom: 15px;
      display: flex;
      align-items: flex-end;
      gap: 10px;
    }
    
    .message.sent {
      flex-direction: row-reverse;
    }
    
    .message-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #2979ff;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 12px;
    }
    
    .message.sent .message-avatar {
      background: #4caf50;
    }
    
    .message-content {
      max-width: 70%;
      background: #ffffff;
      padding: 8px 12px;
      border-radius: 18px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      border: 1px solid #e9ecef;
    }
    
    .message.sent .message-content {
      background: #dcf8c6;
      border: 1px solid #dcf8c6;
      margin-left: auto;
    }
    
    .message-sender {
      font-size: 12px;
      font-weight: 600;
      color: #666;
      margin-bottom: 4px;
    }
    
    .message-footer {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      margin-top: 4px;
      gap: 4px;
    }
    
    .message-time {
      font-size: 11px;
      color: #999999;
      font-weight: 400;
    }
    
    .message-status {
      font-size: 12px;
      color: #999999;
      display: flex;
      align-items: center;
    }
    
    .message-status.sent {
      color: #999999;
    }
    
    .message-status.delivered {
      color: #4fc3f7;
    }
    
    .message-status.read {
      color: #4fc3f7;
    }
    
    .message-status.sending {
      color: #999999;
      opacity: 0.7;
    }
    
    .message-time {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 4px;
    }
    
    .message.sent .message-time {
      text-align: right;
    }
    
    /* Input area */
    .input-area {
      padding: 20px;
      border-top: 1px solid #e9ecef;
      background: #fff;
    }
    
    .input-container {
      display: flex;
      gap: 10px;
      align-items: flex-end;
    }
    
    .message-input {
      flex: 1;
      padding: 12px 16px;
      border: 1px solid #ddd;
      border-radius: 20px;
      resize: none;
      font-family: inherit;
      font-size: 14px;
      max-height: 100px;
      min-height: 40px;
    }
    
    .message-input:focus {
      outline: none;
      border-color: #2979ff;
    }
    
    .send-btn {
      background: #2979ff;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 20px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s;
    }
    
    .send-btn:hover {
      background: #1565c0;
    }
    
    .send-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    /* Empty state */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #666;
      text-align: center;
    }
    
    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .main-container {
        flex-direction: column;
      }
      
      .sidebar {
        width: 100%;
        height: 200px;
      }
      
      .contacts-list {
        display: flex;
        overflow-x: auto;
        overflow-y: hidden;
      }
      
      .contact-item {
        min-width: 200px;
        border-right: 1px solid #e9ecef;
        border-bottom: none;
      }
    }
    
    /* Typing indicator */
    .typing-indicator {
      display: none;
      padding: 10px 20px;
      font-size: 12px;
      color: #666;
      font-style: italic;
    }
    
    .typing-indicator.show {
      display: block;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Admin Messaging</h1>
    <a href="dashboard.html" class="back-btn">‚Üê Back to Dashboard</a>
  </div>
  
  <div class="main-container">
    <!-- Online Users Panel -->
    <div class="user-panel">
      <div class="online-users" id="online-users">
        <h2>Group Chat</h2>
        <h3>Online Users</h3>
        <div class="users-list" id="users-list">
          <!-- Online users will be shown here -->
        </div>
      </div>
    </div>
    
    <!-- Group Chat Area -->
    <div class="chat-area">
      <div class="chat-header" id="chat-header">
        <div class="chat-avatar">üë•</div>
        <div class="chat-info">
          <h3 id="chat-name">Group Chat</h3>
          <div class="chat-status" id="chat-status">All users can see messages here</div>
        </div>
      </div>
      
      <div class="messages-container" id="messages-container">
        <div class="welcome-message">
          <h3>Welcome to Group Chat</h3>
          <p>Select your identity and join the conversation!</p>
        </div>
      </div>
      
      <div class="typing-indicator" id="typing-indicator">
        <span id="typing-text">Someone is typing...</span>
      </div>
      
      <div class="input-area" id="input-area">
        <div class="input-container">
          <textarea 
            class="message-input" 
            id="message-input" 
            placeholder="Type a message to everyone..."
            rows="1"
          ></textarea>
          <button class="send-btn" id="send-btn">Send</button>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    class AdminMessaging {
      constructor() {
        this.groupMessages = [];
        this.isConnected = false;
        this.userId = 'user_' + Date.now();
        this.userName = 'User ' + Math.floor(Math.random() * 1000);
        this.ws = null;
        
        this.initializeElements();
        this.setupEventListeners();
        this.connectWebSocket();
      }
      
      initializeElements() {
        this.chatHeader = document.getElementById('chat-header');
        this.chatName = document.getElementById('chat-name');
        this.chatStatus = document.getElementById('chat-status');
        this.messagesContainer = document.getElementById('messages-container');
        this.inputArea = document.getElementById('input-area');
        this.messageInput = document.getElementById('message-input');
        this.sendBtn = document.getElementById('send-btn');
        this.typingIndicator = document.getElementById('typing-indicator');
        this.typingText = document.getElementById('typing-text');
        
        // Online users elements
        this.usersList = document.getElementById('users-list');
        this.onlineUsers = document.getElementById('online-users');
      }
      
      setupEventListeners() {
        this.sendBtn.addEventListener('click', () => this.sendMessage());
        this.messageInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            this.sendMessage();
          }
        });
        
        this.messageInput.addEventListener('input', () => {
          this.adjustTextareaHeight();
          this.simulateTyping();
        });
      }
      
      loadContacts() {
        // Load real admins from database
        this.loadRealAdmins();
      }
      
      async loadRealAdmins() {
        try {
          const response = await fetch('/api/admin/users');
          if (response.ok) {
            const users = await response.json();
            // Load all active users (admins and workers)
            this.realAdmins = users.filter(user => user.is_active === 1);
            
            // Convert to contact format
            this.contacts = this.realAdmins.map(user => ({
              id: user.id.toString(),
              name: user.name,
              role: this.getUserRole(user.is_admin, user.level),
              isAdmin: user.is_admin === 1,
              status: 'offline' // Will be updated when they come online
            }));
            
            console.log('‚úÖ Loaded all users for chat:', this.contacts);
            this.populateUserSelect();
            this.renderOnlineUsers();
          } else {
            console.log('‚ö†Ô∏è Could not load users, using fallback');
            this.loadFallbackContacts();
          }
        } catch (error) {
          console.error('‚ùå Error loading users:', error);
          this.loadFallbackContacts();
        }
      }
      
      loadFallbackContacts() {
        // Fallback contacts if API fails
        const contacts = [
          { id: 'admin1', name: 'CEO Newton', role: 'CEO', status: 'online' },
          { id: 'admin2', name: 'HR Manager', role: 'HR Manager', status: 'online' },
          { id: 'admin3', name: 'Financial Manager', role: 'Financial Manager', status: 'online' },
          { id: 'admin4', name: 'System Admin', role: 'System Administrator', status: 'offline' },
          { id: 'admin5', name: 'Support Admin', role: 'Support Administrator', status: 'online' }
        ];
        
        this.contacts = contacts;
        this.renderContacts(contacts);
      }
      
      getUserRole(isAdmin, level) {
        if (isAdmin) {
          const adminRoleMap = {
            9: 'CEO',
            8: 'Senior Manager',
            7: 'System Administrator',
            6: 'Support Administrator',
            5: 'Manager',
            4: 'Supervisor',
            3: 'Lead',
            2: 'Senior',
            1: 'Junior',
            0: 'Temporary Worker'
          };
          return adminRoleMap[level] || 'Admin';
        } else {
          const workerRoleMap = {
            5: 'Senior Worker',
            4: 'Lead Worker',
            3: 'Experienced Worker',
            2: 'Skilled Worker',
            1: 'Worker',
            0: 'New Worker'
          };
          return workerRoleMap[level] || 'Worker';
        }
      }
      
      getAdminRole(level) {
        const roleMap = {
          9: 'CEO',
          8: 'Senior Manager',
          7: 'System Administrator',
          6: 'Support Administrator',
          5: 'Manager',
          4: 'Supervisor',
          3: 'Lead',
          2: 'Senior',
          1: 'Junior',
          0: 'Temporary Worker'
        };
        return roleMap[level] || 'Admin';
      }
      
      populateUserSelect() {
        this.userSelect.innerHTML = '<option value="">Choose a user...</option>';
        
        this.realAdmins.forEach(user => {
          const option = document.createElement('option');
          option.value = user.id;
          option.textContent = `${user.name} (${this.getUserRole(user.is_admin, user.level)}) ${user.is_admin ? 'üëë' : 'üë∑'}`;
          this.userSelect.appendChild(option);
        });
      }
      
      handleUserSelection() {
        const selectedUserId = this.userSelect.value;
        this.loginBtn.disabled = !selectedUserId;
        
        if (selectedUserId) {
          this.loginBtn.textContent = `Join as ${this.userSelect.options[this.userSelect.selectedIndex].textContent}`;
        } else {
          this.loginBtn.textContent = 'Join Chat';
        }
      }
      
      loginAsSelectedUser() {
        const selectedUserId = this.userSelect.value;
        if (!selectedUserId) return;
        
        const selectedUser = this.realAdmins.find(user => user.id.toString() === selectedUserId);
        if (!selectedUser) return;
        
        // Update admin credentials
        this.adminId = selectedUserId;
        this.adminName = selectedUser.name;
        
        // Store in localStorage
        localStorage.setItem('adminId', this.adminId);
        localStorage.setItem('adminName', this.adminName);
        
        // Update UI
        this.loginBtn.textContent = `Joined as ${selectedUser.name}`;
        this.loginBtn.classList.add('logged-in');
        this.loginBtn.disabled = true;
        this.userSelect.disabled = true;
        
        // Show logout button
        this.logoutBtn.style.display = 'block';
        
        // Connect to WebSocket with new credentials
        if (this.ws) {
          this.ws.close();
        }
        this.connectWebSocket();
        
        console.log(`‚úÖ Logged in as: ${selectedUser.name} (${this.getUserRole(selectedUser.is_admin, selectedUser.level)})`);
      }
      
      renderOnlineUsers() {
        this.usersList.innerHTML = '';
        
        this.contacts.forEach(user => {
          const userItem = document.createElement('div');
          userItem.className = 'user-item';
          
          const avatar = document.createElement('div');
          avatar.className = `user-avatar ${user.isAdmin ? 'admin' : 'worker'}`;
          avatar.textContent = user.name.charAt(0).toUpperCase();
          
          const userInfo = document.createElement('div');
          userInfo.className = 'user-info';
          
          const userName = document.createElement('div');
          userName.className = 'user-name';
          userName.textContent = user.name;
          
          const userRole = document.createElement('div');
          userRole.className = 'user-role';
          userRole.textContent = user.role;
          
          userInfo.appendChild(userName);
          userInfo.appendChild(userRole);
          
          const status = document.createElement('div');
          status.className = `user-status ${user.status}`;
          
          userItem.appendChild(avatar);
          userItem.appendChild(userInfo);
          userItem.appendChild(status);
          
          this.usersList.appendChild(userItem);
        });
      }
      
      logout() {
        // Clear credentials
        this.adminId = 'admin';
        this.adminName = 'Admin';
        localStorage.removeItem('adminId');
        localStorage.removeItem('adminName');
        
        // Disconnect WebSocket
        if (this.ws) {
          this.ws.close();
        }
        
        // Reset UI
        this.loginBtn.textContent = 'Join Chat';
        this.loginBtn.classList.remove('logged-in');
        this.loginBtn.disabled = true;
        this.userSelect.disabled = false;
        this.userSelect.value = '';
        
        // Hide logout button
        this.logoutBtn.style.display = 'none';
        
        // Clear chat area
        this.messagesContainer.innerHTML = '';
        this.currentContact = null;
        
        console.log('‚úÖ Logged out');
      }
      
      renderContacts(contacts) {
        this.contactsList.innerHTML = '';
        
        contacts.forEach(contact => {
          const contactItem = document.createElement('div');
          contactItem.className = 'contact-item';
          contactItem.setAttribute('data-id', contact.id);
          
          contactItem.innerHTML = `
            <div class="contact-avatar ${contact.isAdmin ? 'admin' : 'worker'}">${contact.name.charAt(0).toUpperCase()}</div>
            <div class="contact-info">
              <div class="contact-name">${contact.name}</div>
              <div class="contact-role">${contact.role} ${contact.isAdmin ? 'üëë' : 'üë∑'}</div>
            </div>
            <div class="contact-status ${contact.status === 'online' ? '' : 'offline'}"></div>
          `;
          
          contactItem.addEventListener('click', () => this.selectContact(contact));
          this.contactsList.appendChild(contactItem);
        });
      }
      
      selectContact(contact) {
        // Remove active class from all contacts
        document.querySelectorAll('.contact-item').forEach(item => {
          item.classList.remove('active');
        });
        
        // Add active class to selected contact
        const contactItem = document.querySelector(`[data-id="${contact.id}"]`);
        if (contactItem) {
          contactItem.classList.add('active');
        }
        
        this.currentContact = contact;
        this.showChatArea();
        this.loadMessages(contact.id);
      }
      
      showChatArea() {
        this.chatHeader.style.display = 'flex';
        this.inputArea.style.display = 'block';
        
        this.chatAvatar.textContent = this.currentContact.name.charAt(0).toUpperCase();
        this.chatName.textContent = this.currentContact.name;
        this.chatStatus.textContent = `${this.currentContact.role} ‚Ä¢ ${this.currentContact.status === 'online' ? 'Online' : 'Offline'}`;
        
        // Hide empty state
        const emptyState = this.messagesContainer.querySelector('.empty-state');
        if (emptyState) {
          emptyState.style.display = 'none';
        }
      }
      
      loadMessages(contactId) {
        // Load existing messages or create empty array
        if (!this.messages.has(contactId)) {
          this.messages.set(contactId, []);
        }
        
        const contactMessages = this.messages.get(contactId);
        this.renderMessages(contactMessages);
      }
      
      renderMessages(messages) {
        this.messagesContainer.innerHTML = '';
        
        if (messages.length === 0) {
          const emptyState = document.createElement('div');
          emptyState.className = 'empty-state';
          emptyState.innerHTML = `
            <div class="empty-state-icon">üí¨</div>
            <h3>Start a conversation</h3>
            <p>Send a message to ${this.currentContact.name}</p>
          `;
          this.messagesContainer.appendChild(emptyState);
          return;
        }
        
        messages.forEach(message => {
          this.addMessageToUI(message);
        });
        
        this.scrollToBottom();
      }
      
      addMessageToUI(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${message.senderId === this.userId ? 'sent' : 'received'}`;
        messageDiv.dataset.messageId = message.id;
        
        const content = document.createElement('div');
        content.className = 'message-content';
        
        // Add sender name for group messages (except for own messages)
        if (message.senderId !== this.userId && message.senderName) {
          const senderName = document.createElement('div');
          senderName.className = 'message-sender';
          senderName.textContent = message.senderName;
          content.appendChild(senderName);
        }
        
        const text = document.createElement('p');
        text.className = 'message-text';
        text.textContent = message.text;
        
        const messageFooter = document.createElement('div');
        messageFooter.className = 'message-footer';
        
        const time = document.createElement('div');
        time.className = 'message-time';
        time.textContent = this.formatTime(message.timestamp);
        
        // Add status indicator for sent messages
        if (message.senderId === this.userId) {
          const status = document.createElement('div');
          status.className = `message-status ${message.status || 'sending'}`;
          status.innerHTML = this.getStatusIcon(message.status || 'sending');
          messageFooter.appendChild(status);
        }
        
        messageFooter.appendChild(time);
        content.appendChild(text);
        content.appendChild(messageFooter);
        
        messageDiv.appendChild(content);
        
        this.messagesContainer.appendChild(messageDiv);
        
        // Auto-scroll for group messages
        setTimeout(() => {
          this.scrollToBottom();
        }, 100);
      }
      
      sendMessage() {
        const text = this.messageInput.value.trim();
        if (!text) return;
        
        const message = {
          id: Date.now(),
          text: text,
          senderId: this.userId,
          senderName: this.userName,
          timestamp: new Date(),
          status: 'sending'
        };
        
        // Send via real WebSocket server
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify({
            type: 'send_group_message',
            content: text,
            messageType: 'text'
          }));
          console.log(`üì§ Sent group message: ${text}`);
        } else {
          console.log('‚ùå WebSocket not connected, cannot send message');
          return;
        }
        
        // Add to group messages
        if (!this.groupMessages) this.groupMessages = [];
        this.groupMessages.push(message);
        
        // Add to UI
        this.addMessageToUI(message);
        
        // Clear input
        this.messageInput.value = '';
        this.adjustTextareaHeight();
        
        // Scroll to bottom
        this.scrollToBottom();
      }
      
      simulateTyping() {
        if (!this.currentContact || !this.isConnected) return;
        
        // Send typing indicator via WebSocket if available
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify({
            type: 'typing_start',
            toAdminId: this.currentContact.id
          }));
          
          // Stop typing indicator after 2 seconds
          clearTimeout(this.typingTimeout);
          this.typingTimeout = setTimeout(() => {
            this.ws.send(JSON.stringify({
              type: 'typing_stop',
              toAdminId: this.currentContact.id
            }));
          }, 2000);
        } else {
          // Simulation mode - show typing indicator
          this.typingIndicator.classList.add('show');
          this.typingText.textContent = `${this.currentContact.name} is typing...`;
          
          clearTimeout(this.typingTimeout);
          this.typingTimeout = setTimeout(() => {
            this.typingIndicator.classList.remove('show');
          }, 2000);
        }
      }
      
      adjustTextareaHeight() {
        this.messageInput.style.height = 'auto';
        this.messageInput.style.height = Math.min(this.messageInput.scrollHeight, 100) + 'px';
      }
      
      scrollToBottom() {
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
      }
      
      formatTime(timestamp) {
        return timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }
      
      filterContacts(query) {
        const filtered = this.contacts.filter(contact => 
          contact.name.toLowerCase().includes(query.toLowerCase()) ||
          contact.role.toLowerCase().includes(query.toLowerCase())
        );
        this.renderContacts(filtered);
      }
      
      connectWebSocket() {
        try {
          // Connect to real Admin Messaging Server
          this.ws = new WebSocket('ws://localhost:4001/admin-messaging');
          
          this.ws.onopen = () => {
            console.log('‚úÖ Connected to Group Chat Server');
            this.isConnected = true;
            this.updateConnectionStatus('Connected', 'connected');
            
            // Send anonymous login
            this.ws.send(JSON.stringify({
              type: 'anonymous_login',
              userId: this.userId,
              userName: this.userName
            }));
          };
          
          this.ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            this.handleWebSocketMessage(message);
          };
          
          this.ws.onclose = () => {
            console.log('‚ùå Disconnected from Group Chat Server');
            this.isConnected = false;
            this.updateConnectionStatus('Disconnected', 'disconnected');
            
            // Try to reconnect after 3 seconds
            setTimeout(() => {
              if (!this.isConnected) {
                console.log('üîÑ Attempting to reconnect to group chat server...');
                this.connectWebSocket();
              }
            }, 3000);
          };
          
          this.ws.onerror = (error) => {
            console.error('‚ùå WebSocket error:', error);
            this.updateConnectionStatus('Connection Error', 'disconnected');
            
            // Fallback to simulation mode if server is not running
            setTimeout(() => {
              if (!this.isConnected) {
                console.log('‚ö†Ô∏è Server not available, using simulation mode');
                this.enableSimulationMode();
              }
            }, 2000);
          };
          
        } catch (error) {
          console.error('‚ùå Error connecting to WebSocket:', error);
          this.updateConnectionStatus('Connection Failed', 'disconnected');
          
          // Fallback to simulation mode
          setTimeout(() => {
            this.enableSimulationMode();
          }, 2000);
        }
      }
      
      enableSimulationMode() {
        console.log('üîÑ Enabling simulation mode for messaging');
        this.isConnected = true; // Simulate connection
        this.simulateWebSocketConnection();
      }
      
      handleWebSocketMessage(message) {
        console.log('üì® Received message:', message.type);
        
        switch (message.type) {
          case 'login_success':
            console.log('‚úÖ Admin login successful:', message.adminName);
            this.updateConnectionStatus(`Logged in as ${message.adminName}`, 'connected');
            // Request online admins list
            this.ws.send(JSON.stringify({ type: 'get_online_admins' }));
            break;
            
          case 'online_admins':
            this.updateOnlineAdmins(message.admins);
            break;
            
          case 'admin_online':
            this.handleAdminOnline(message);
            break;
            
          case 'admin_offline':
            this.handleAdminOffline(message);
            break;
            
          case 'new_message':
            this.handleReceivedMessage(message);
            break;
            
          case 'group_message':
            this.handleGroupMessage(message);
            break;
            
          case 'message_sent':
            console.log('‚úÖ Message sent successfully');
            this.updateMessageStatus(message.messageId, 'sent');
            break;
            
          case 'message_delivered':
            console.log('‚úÖ Message delivered');
            this.updateMessageStatus(message.messageId, 'delivered');
            break;
            
          case 'messages_read':
            console.log('‚úÖ Messages read by', message.readByName);
            this.updateMessagesAsRead(message.messageIds);
            break;
            
          case 'typing_start':
            this.handleTypingStart(message);
            break;
            
          case 'typing_stop':
            this.handleTypingStop(message);
            break;
            
          case 'error':
            console.error('‚ùå Server error:', message.message);
            this.updateConnectionStatus(`Error: ${message.message}`, 'disconnected');
            break;
            
          default:
            console.log('‚ö†Ô∏è Unknown message type:', message.type);
        }
      }
      
      updateOnlineAdmins(admins) {
        // Update contacts list with online status
        this.contacts.forEach(contact => {
          const onlineAdmin = admins.find(admin => admin.adminId === contact.id);
          contact.status = onlineAdmin ? 'online' : 'offline';
        });
        this.renderContacts(this.contacts);
      }
      
      handleAdminOnline(message) {
        console.log(`üë§ ${message.adminName} is now online`);
        // Update contact status
        const contact = this.contacts.find(c => c.id === message.adminId);
        if (contact) {
          contact.status = 'online';
          this.renderContacts(this.contacts);
        }
      }
      
      handleAdminOffline(message) {
        console.log(`üë§ ${message.adminName} is now offline`);
        // Update contact status
        const contact = this.contacts.find(c => c.id === message.adminId);
        if (contact) {
          contact.status = 'offline';
          this.renderContacts(this.contacts);
        }
      }
      
      handleTypingStart(message) {
        if (this.currentContact && this.currentContact.id === message.fromAdminId) {
          this.showTypingIndicator(`${message.fromAdminName} is typing...`);
        }
      }
      
      handleTypingStop(message) {
        if (this.currentContact && this.currentContact.id === message.fromAdminId) {
          this.hideTypingIndicator();
        }
      }
      
      handleAdminJoined(message) {
        console.log(`üë§ ${message.adminName} joined`);
        // Update contact status if they're in our contacts
        const contact = this.contacts.find(c => c.id === message.adminId);
        if (contact) {
          contact.status = 'online';
          this.renderContacts(this.contacts);
        }
      }
      
      handleAdminLeft(message) {
        console.log(`üëã ${message.adminName} left`);
        // Update contact status
        const contact = this.contacts.find(c => c.id === message.adminId);
        if (contact) {
          contact.status = 'offline';
          this.renderContacts(this.contacts);
        }
      }
      
      handleReceivedMessage(message) {
        console.log('üì® Received message from:', message.fromAdminName);
        
        // Convert server message format to local format
        const localMessage = {
          id: Date.now(),
          text: message.content,
          senderId: message.fromAdminId,
          senderName: message.fromAdminName,
          receiverId: this.adminId,
          receiverName: this.adminName,
          timestamp: new Date(message.timestamp)
        };
        
        // Add message to the sender's conversation
        const contactMessages = this.messages.get(message.fromAdminId) || [];
        contactMessages.push(localMessage);
        this.messages.set(message.fromAdminId, contactMessages);
        
        // Add to UI if we're viewing this conversation
        if (this.currentContact && this.currentContact.id === message.fromAdminId) {
          this.addMessageToUI(localMessage);
        }
        
        // Show notification if not viewing this conversation
        if (!this.currentContact || this.currentContact.id !== message.fromAdminId) {
          this.showMessageNotification(message.fromAdminName, message.content);
        }
      }
      
      handleGroupMessage(message) {
        console.log('üì¢ Received group message from:', message.fromAdminName);
        
        // Convert server message format to local format
        const localMessage = {
          id: message.messageId,
          text: message.content,
          senderId: message.fromAdminId,
          senderName: message.fromAdminName,
          senderRole: message.fromAdminRole,
          timestamp: new Date(message.timestamp),
          status: message.status
        };
        
        // Add to group messages
        if (!this.groupMessages) this.groupMessages = [];
        this.groupMessages.push(localMessage);
        
        // Add to UI
        this.addMessageToUI(localMessage);
        
        // Show notification
        this.showMessageNotification(`${message.fromAdminName} (${message.fromAdminRole})`, message.content);
      }
      
      showMessageNotification(senderName, content) {
        // Create a simple notification
        const notification = document.createElement('div');
        notification.className = 'message-notification';
        notification.innerHTML = `
          <div class="notification-content">
            <strong>${senderName}</strong>: ${content.substring(0, 50)}${content.length > 50 ? '...' : ''}
          </div>
        `;
        
        // Add styles
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #007bff;
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          z-index: 1000;
          max-width: 300px;
          animation: slideIn 0.3s ease-out;
        `;
        
        document.body.appendChild(notification);
        
        // Remove after 5 seconds
        setTimeout(() => {
          notification.remove();
        }, 5000);
      }
      
      updateMessageStatus(messageId, status) {
        // Find and update message status in UI
        const messageElements = document.querySelectorAll('.message');
        messageElements.forEach(element => {
          if (element.dataset.messageId === messageId.toString()) {
            const statusElement = element.querySelector('.message-status');
            if (statusElement) {
              statusElement.className = `message-status ${status}`;
              statusElement.innerHTML = this.getStatusIcon(status);
            }
          }
        });
      }
      
      updateMessagesAsRead(messageIds) {
        messageIds.forEach(messageId => {
          this.updateMessageStatus(messageId, 'read');
        });
      }
      
      getStatusIcon(status) {
        switch (status) {
          case 'sending':
            return '‚è≥';
          case 'sent':
            return '‚úì';
          case 'delivered':
            return '‚úì‚úì';
          case 'read':
            return '‚úì‚úì';
          default:
            return '‚è≥';
        }
      }
      
      markMessagesAsRead() {
        if (!this.currentContact || !this.ws || this.ws.readyState !== WebSocket.OPEN) return;
        
        // Get unread messages from current contact
        const unreadMessages = this.messages.get(this.currentContact.id) || [];
        const unreadIds = unreadMessages
          .filter(msg => msg.senderId !== this.adminId && msg.status !== 'read')
          .map(msg => msg.id);
        
        if (unreadIds.length > 0) {
          this.ws.send(JSON.stringify({
            type: 'mark_as_read',
            messageIds: unreadIds,
            fromAdminId: this.currentContact.id
          }));
        }
      }
      
      handleTypingIndicator(message) {
        if (this.currentContact && message.senderId === this.currentContact.id) {
          this.typingIndicator.classList.add('show');
          this.typingText.textContent = `${message.senderName} is typing...`;
          
          clearTimeout(this.typingTimeout);
          this.typingTimeout = setTimeout(() => {
            this.typingIndicator.classList.remove('show');
          }, 2000);
        }
      }
      
      simulateWebSocketConnection() {
        // This method enables simulation mode when WebSocket is not available
        console.log('üîÑ Simulation mode enabled - messaging will work with simulated responses');
        
        // Simulate connection status
        setTimeout(() => {
          this.isConnected = true;
          console.log('‚úÖ Simulation mode: Connected');
          
          // Use real admins if available, otherwise use fallback
          if (this.contacts && this.contacts.length > 0) {
            console.log('‚úÖ Using real admin contacts in simulation mode');
          } else {
            console.log('‚ö†Ô∏è No real admins available, using fallback contacts');
            this.loadFallbackContacts();
          }
        }, 1000);
      }
    }
    
    // Initialize messaging when page loads
    document.addEventListener('DOMContentLoaded', () => {
      new AdminMessaging();
    });
  </script>
</body>
</html>
